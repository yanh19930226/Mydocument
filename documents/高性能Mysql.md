# 高性能Mysql

## 逻辑架构

第一层：大多数基于网络的客户端/服务器的工具等架构，如连接处理，授权认证，安全等；

第二层：核心功能服务都在这一层，包括查询解析、分析、优化、缓存等。跨存储引擎的功能都在这一层：存储过程，触发器，视图；

第三层：包含存储引擎；



### 连接管理

每个客户端连接都会在服务器进程中拥有一个连接。服务器会负责缓存线程，所以不需要为每一个新建的连接创建或销毁线程；使用SSL方式进行连接。

### 优化与执行

Mysql会解析查询，并创建解析树，对其进行优化，包括重写查询，决定表的读取顺序，选择合适的索引等；用户可以通过优化器解释（explain）优化过程的各个因素，可以指导服务器时如何进行决策优化的；也可以使用hint来影响决策过程；

### 锁粒度

提高共享资源并发性的方式就是让锁定对象更有选择性。 尽量只锁定需要修改的部分数据，而不是所有资源。

#### 表锁

是基本的锁策略，开销最小，会锁定整张表。只有添加写锁的时候才会阻塞其他用户的读写操作，读锁之间是不互相阻塞的；写锁的优先级高于读锁，更容易争抢到锁；

#### 行级锁



### 基准测试

指标：数据库在一定工作负荷量的情况下的响应时间，

#### 测试工具

集成式测试工具

单组件式测试工具







## 索引和锁

索引能够过滤掉不需要访问的行，从而减少锁的数量（InnoDB的行锁），减少额外的开销；

从存储中进行读取时，尽可能在一次IO中取出包含尽可能多所需要的行。

按顺序访问范围数据，因为IO不需要多次磁盘寻道，所以比随机IO要快很多。并且不需要额外的排序操作。

索引覆盖查询很快，如果一个索引包含了查询需要的所有列，那么存储引擎就不需要再回表进行查询。

### 冗余索引和重复索引

如果创建了索引（A，B） 再创建索引（A）就是冗余索引，而索引（B,A）和索引（B）都不是冗余索引；

### 优化索引

1、支持多种过滤条件；2、避免多个范围条件、



## 慢查询优化

### 优化数据访问

#### 是否向数据库访问了不需要的数据

1. 查询了不需要的记录；
2. 多表关联的时候返回了全部列
3. 总是取出全部列 （select *）
4. 重复查询相同的数据

#### 是否在扫描额外的记录

1. 响应时间
2. 扫描的行数和返回的行数   有时候扫描了n行 却只返回了若干行
3. 扫描的行数和访问类型

#### 重构查询的方式

1. 使用一个复杂查询还是多个简单查询
2. 切分查询   将一个范围很大的查询分成多个功能相同 范围不同的小查询，有时这样更有效
3. 分解关联查询      执行单个查询可以减少锁的竞争，可以减少冗余记录的查询；



#### 优化的总结

理解查询是如何被执行的以及时间都消耗在了什么地方。

优化所作的时间一般是：不做，少做，快速的做；



## 高级特性

#### 分区表

实现分区的代码实际上是对一组底层表的句柄对象的封装。

在创建表时通过使用**partition by**来定义每个分区存放的数据，这样在执行查询的时候，优化器会根据分区定义过滤掉没有我们需要数据的分区，这样就无需扫描所有分区。

作用：

- 表非常大时无法全部存放在内存中，或者只在表的最后部分有热点数据，其他均是历史数据
- 分区表的数据更容易维护，比如可以批量删除大量的数据可以使用清除整个分区的方式，或对一个独立的分区进行优化，检查，修复等操作。
- 分区表的数据可以分布在不同的物理设备上，从而高效的利用多个硬件设备。
- 可以在一定程度上避免某些特殊的瓶颈，如在innodb中的单个索引的互斥访问。

限制：

- 一个表最多只能由1024个分区
- 分区表中无法使用外键约束

#### 视图

对多个表的复杂查询，使用视图时会大大简化问题。 

#### 外键约束

#### 查询缓存

Mysql查询缓存会保存查询返回的完整结果，当查询命中该缓存，mysql会立刻返回结果，跳过了解析、优化和执行阶段。

如果表被修改，那么缓存数据都将失效。

##### 判断是否命中缓存：

查询本身、当前要查询的数据库、客户端协议的版本等。

如果查询语句中包含不确定的数据，则不会被缓存，如DATE（），NOW（）等，并且如果查询中包含用户自定义函数、用户变量、存储函数等，都不会被缓存。



查询缓存时完全存储在内存之中的。

缓存未命中的原因：

- 查询语句无法被缓存，或者查询结果太大而无法缓存。
- 当前查询从未被处理过，所以结果也没有被缓存过。
- 虽然之前缓存了查询结果，但由于查询缓存的内存用完了，需要将某些缓存逐出，或者由于表被修改导致缓存失效了。

若服务器中有大量缓存未命中，但实际上绝大多数查询都被缓存了，可能是：

- 查询缓存还没有完成预热，mysql还没有机会将查询语句全都缓存起来；
- 查询语句之前从未执行过。
- 缓存失效操作太多了。（缓存碎片，内存不足，数据修改都会造成缓存失效）



## 复制

复制解决的基本问题是让一台服务器的数据与其他服务器保持同步。一同主库的数据可以同步到多台备库上，备库本身也可以被配置乘另外一台服务器的主库。

两种复制方式：**基于行的复制**和**基于语句的复制**。

因为mysql复制大部分时向后兼容的，新版本的服务器可以作为老版本服务器的备库，但不能反过来，因为老版本的服务器可能无法解析新版本所使用的新的特性或语法。

### 复制解决的问题

数据分布：将数据分布在不同的地理位置。

负载均衡：将读操作分布到多个服务器上，实现对密集型应用的优化。

备份：复制对于备份是一项有意义的技术补充，但它不是备份也无法替代备份。

高可用性和故障切换：当前服务器出现故障时，可以切换到另一个系统能够显著的减少宕机的时间。

Mysql升级测试



### 如何工作

1. 在主库上把数据更改记录到二进制日志中。
2. 备库将主库上的日志复制到自己的中继日志中。
3. 备库读取中继日志中的事件，将其重放到备库数据之上。



### 复制的问题和解决方案

#### 数据损坏或丢失的错误

大部分问题都是由于非正常关机导致的复制问题都是由于没有把数据及时的地刷到磁盘；

##### 主库意外关闭

可能在崩溃将没有将最后几个二进制日志事件刷新到磁盘中。

解决方案是从指定备库从下一个二进制日志的开头读日志。

##### 备库意外关闭

解决的办法大部分都是忽略那些错误，因为很难去定位之前发生错误的位置。

##### 主库上的二进制日志损毁

除了忽略损坏的位置外别无选择。

##### 备库上的中继日志损坏

重新获取主库中的日志。



## 可扩展性

可扩展性表明了当需要增加资源以执行更多工作时系统能够获得划算的等同提升的能力。

缺乏扩展能力的系统在达到收益递减的转折点后，将无法进一步增长。



### 扩展

#### 向上扩展

购置更新更好的设备

#### 向外扩展

- 按功能拆分
- 数据分片

#### 通过多实例扩展

可以在一台性能强悍的服务器上运行多个服务器实例。

#### 集群扩展

建立一个集群或者网络，自动扩展，动态的增加/移除服务器。

#### 向内扩展

对不需要的数据进行归档和清理。



### 负载均衡

在一个服务器集群中尽可能地平均负载量。通常在服务器前端设置一个负载均衡器，将请求的连接转发到最空闲的可用服务器。

负载均衡的五个常见目的：**可扩展性**，**高效性**，**可用性**，**透明性**，**一致性**。

 负载均衡的算法：随机，轮询，最少连接数，最快响应，哈希，权重。



##  高可用性

宕机时间越少，表明可用性越高。

### 导致宕机的原因

- 运行环境中最普遍的问题是磁盘空间耗尽
- 性能问题中，最普遍的宕机原因是运行很糟糕的SQL，或服务器Bug或是错误的行为导致。
- 复制问题通常由于主从数据不一致导致。

### 如何实现高可用性

提升平均失效时间（两次故障间的正常运行时间）

降低平均恢复时间（从故障中恢复的时间）

为系统建立冗余，并使得系统具备故障转移的能力，这样就可以在发生故障时及时专业到其他服务器继续运行。



## 事务隔离

使用set autocommit=0时，事务不会自己提交，需要手动提交，但有时我们需要长事务时，不想要自动提交，但又希望主动去执行一次begin操作，为了减少语句的交互次数，我们可以使用==commit work and chain==语法，该语法的作用是，提交事务并自动启动下一个事务，省去了再次执行begin语句的开销，同时带来的好处是从程序开发的角度明确地知道每个语句是否处于事务中。

可以在information_schema库的innode_trx这个表中查询长事务

```sql
select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60
```

### 开发过程中如何避免长事务

尽可能的减小事务范围，少用长事务，如果无法避免，保证逻辑日志空间足够用，并且支持动态日志空间增长。监控innodb_trx表，发现长事务报警。



## 索引

==索引的出现其实就是为了提高数据查询的效率。==

常见的数据结构有哈希表、有序数组和搜索树。

### 哈希

哈希表是一种以键 - 值（key-value）存储数据的结构，我们只要输入待查找的键即 key，就可以找到其对应的值即 Value。

哈希的思路很简单，把值放在数组里，用一个哈希函数把 key 换算成一个确定的位置，然后把 value 放在数组的这个位置。

优点是插入时速度很快，只需要往后追加。

缺点就是数据并不是有序的，查询时会很慢。所以使用哈希表时不能使用范围查询，只适用于等值查询的场景。

### 有序数组

有序数组在等值查询和范围查询场景中的性能都非常优秀。通过使用二分等查询算法就能很快的查询到我们需要的数据。

但是有序数组在做插入删除操作时就很麻烦了，在中间插入一个记录就必须挪动后面所有的记录，成本太高。

所以，有序数组索引只适用于静态存储引擎。

### 二叉搜索树

特点是：父节点左子树所有节点的值小于父节点的值，右子树所有节点的值大于父节点。

为了维持Ologn的查询复杂度，就需要保证这棵树时平衡二叉树，所以更新的时间也是Ologn。

树可以有二叉，也可以有多叉。多叉树就是每个节点有多个儿子，儿子之间的大小保证从左到右递增。二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。其原因是，索引不止存在内存中，还要写到磁盘上。

为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N 叉”树。这里，“N 叉”树中的“N”取决于数据块的大小。这就是为什么innodb使用b+树而不是二叉搜索树的原因，降低了树高，就能够减少搜索时IO的次数。

## InnoDB的索引模型

InnoDB使用了B+树索引模型。

B+ 树能够很好地配合磁盘的读写特性，减少单次查询的磁盘访问次数。

有没有什么场景适合用业务字段直接做主键的呢？

还是有的。比如，有些业务的场景需求是这样的：只有一个索引；该索引必须是唯一索引。这就是典型的 KV 场景。



### 最左前缀匹配原则

建立索引的时候按使用的频率来建立，可以少维护索引，以此来有效的利用空间。

使用联合索引时，如果匹配到范围查询，那么之后的字段即便有索引可以走也不会再走索引。在5.6之前，只能从当前已有的范围中一个一个回表，到主键索引上找出数据行，再比对字段值。5.6之后，引入了所以下推优化，可以在索引遍历的过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。

 

## 全局锁和表锁

mysql中的锁可以分为全局锁、表锁和行锁三类。

### 全局锁

对整个数据库实例加所。mysql提供了一个加全局读锁的方法，命令是==Flush tables with read lock==，当需要让整个库处于只读状态时，可以使用整个命令，其他的更新、插入、定义等语句都会被阻塞。

不建议使用set global readonly = true，一是因为有些系统中readonly的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库，因此修改global变量的方式影响面更大，不建议使用。二是异常处理机制上有差异，如果执行FTWRL命令之后客户端发生异常断开，那么mysql会自动释放这个全局锁，整个库恢复到正常更新的状态。而设置readonly之后，如果发生异常，则数据库会一直保持readonly状态，导致整个库长时间处于不可写状态，风险高。

使用场景： 全库的逻辑备份。

- 在主库上备份，那么备份期间都不能执行更行，业务基本停摆。
- 在备库上备份，那么备份期间从库不能执行同步过来的binlog，导致主从延迟。

官方自带的逻辑备份工具是 mysqldump。当 mysqldump 使用参数–single-transaction 的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于 MVCC 的支持，这个过程中数据是可以正常更新的。



### 表级锁

mysql中表级锁有两种：一种是表锁，一种是元数据锁

表锁的语法是lock tables ... read/write，和FTWTL类似，可以通过unlock tables主动释放锁，也可以在客户端断开的时候自动释放。lock tables语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。

另一类表级锁是MDL（metadata lock）。MDL不需要显示使用，在访问一个表的时候会被自动加上。MDL的作用是保证读写的正确性。因此在mysql5.5中引入了MDL，当对一个表做CURD操作的时候，加MDL读锁，当要对表结构做变更的时候，加MDL写锁。

- 读写之间不互斥
- 读写锁、写锁之间是互斥的。用来保证变更表结构操作的安全性。

如何安全的给小表加字段？

首先解决长事务，事务不提交，就会一直站着MDL锁。所以如果要做DLL变更的表刚好有长事务在执行，要考虑先暂停DDL，或者kill掉这个长事务。

如果是一个热点表，数据量不大，但是请求很频繁，而我们又不得不加上新字段如何做？

这个时候kill未必管用，因为新的请求马上就来了。理想的机制是在alter table语句中设定等待时间，如果指定时间内能拿到锁最好，如果拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员或者DBA再重试这个过程。



## 行锁

行锁是引擎曾自己实现的，但并不是所有的引擎都支持行锁。这也是MyISAM呗InnoDB替代的原因之一。

尽可能将可能影响并发度的锁的申请时机尽量放在事务的后面。

#### 死锁和死锁检测

当并发系统中不同线程出现循环资源以来，涉及的线程都在等待别的线程释放资源时，就会导致几个线程都进入无线等待的状态，称为死锁。

当死锁出现后有两种策略：

- 一种策略是，直接进入等待，直到超时，可以通过innodb_lock_wait_timeout来设置
- 另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的一个事务，让其他事务得以继续执行。将参数innodb_deadlock_detect设置为on，表示开启这个逻辑。

如何解决热点行更新导致的性能问题呢？

- 一种方法，如果能确保业务一定不会出现死锁，可以临时把死锁检测关掉。
- 控制并发度，如果并发能够控制得住，那么死锁检测的成本很低，就不会出现性能的问题。
- 将一行改成逻辑上的多行来减少锁冲突。当我们要对改行进行操作的时候，我们可以选择多行中的任意一条来进行更改，冲突率就下降了。



可重复读的核心就是一致性读；而事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。

- 在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；

- 在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。



## 普通索引和唯一索引

### 对于查询操作

两种索引的查询效率相差不大，因为innodb的数据是按数据页为单位来读写的。也就是说，当需要读一条数据的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。所以计算平均性能差异的时候，仍可以认为这个操作对于现在的CPU可以忽略不计。

### 更新过程

当需要更新一个数据页的时候，如果数据页在内存中就直接更新，而如果这个数据页不在内存中的话，在不影响数据一致性的前提下，InnoDB会将这些更新操作缓存在change buffer中，这样就不需要从磁盘中读入这个数据页了。

change buffer 是可以持久化的数据，所以说，change buffer在内存中有拷贝，也会被写入到磁盘中。

将change buffer中的操作应用到原数据页，得到最新的结果的过程称为merge。除了访问这个数据页会触发merge外，系统又后台线程会定期merge。数据库正常关闭的过程中也会执行merge操作。

如果能够将更新操作先记录在changebuffer中，减少读磁盘，语句的执行速度会得到明显的提升。而且，数据读入内存是需要占用buffer pool的，所以这种方式还饿能够避免占用内存，提高内存利用率。

但是对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束，所以必须要将数据页读入内存才能判断，如果都已经读入到内存，那直接更新内存会更快，没必要使用change buffer了。

因此唯一索引的更新就不能使用change buffer，实际上也只有普通索引可以使用。

change buffer用的是buffer pool 里的内存，因此不能无限增大。可以通过参数innodb_change_buffer_max_size来动态设置，这个参数设置为50的时候，表示change buffer的大小最多只能占用buffer pool 的50%。

更新数据的处理流程

- 对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束。
- 对于普通索引来说，则是将更新记录在change buffer中，语句执行就结束了。

并非所有的普通索引change buffer都能起到加速作用。

因为merge的时候是真正进行数据更新的时刻。如果一个数据页做merge之前，change buffer记录的变更越多，那么收益也越大。

所以对于写多读少的业务来说，使用的效果最好。但是如果一个业务更新之后马上会被查询，那么随机访问IO的次数不会减少，反而增加了change buffer的维护代价，起到了副作用。

对于普通索引和唯一索引的选择，查询上效率没太大差别，主要是考虑到对更新性能的影响，所以建议使用普通索引。而是否使用changebuffer，则需要根据具体的业务场景来选择是否开启。



### change buffer

除了上述的说明之外。

change buffer在被记录的同时，还会将更新操作写到redolog和binlog中。